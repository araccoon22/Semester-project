### Average across inter-individual draws
P = apollo_avgInterDraws(P, apollo_inputs, functionality)
### Prepare and return outputs of function
P = apollo_prepareProb(P, apollo_inputs, functionality)
return(P)
}
model = apollo_estimate(apollo_beta, apollo_fixed,apollo_probabilities, apollo_inputs)
knitr::opts_chunk$set(echo = TRUE)
### Clear memory
rm(list = ls())
### Load Apollo library
library(apollo)
### Initialise code
apollo_initialise()
### Set core controls
apollo_control = list(
modelName       = "MMNL_preference_space",
modelDescr      = "Mixed logit model on Swiss route choice data, uncorrelated Lognormals in preference space",
indivID         = "ID",
nCores          = 4,
outputDirectory = "output"
)
### Loading data from package
### if data is to be loaded from a file (e.g. called data.csv),
### the code would be: database = read.csv("data.csv",header=TRUE)
database = apollo_swissRouteChoiceData
### for data dictionary, use ?apollo_swissRouteChoiceData
### Note this is unlabelled data, so we are doing this for an illustration of cheap vs expensive
### Define settings for analysis of choice data to be conducted prior to model estimation
choiceAnalysis_settings <- list(
alternatives = c(cheap=1, expensive=2),
choiceVar    = (1*((database$choice==1)*(database$tc1<=database$tc2)+(database$choice==2)*(database$tc1>=database$tc2))
+2*((database$choice==1)*(database$tc1>=database$tc2)+(database$choice==2)*(database$tc1<=database$tc2))),
explanators  = database[,c("car_availability","hh_inc_abs","business")]
)
### Run function to analyse choice data
apollo_choiceAnalysis(choiceAnalysis_settings, apollo_control, database)
### Vector of parameters, including any that are kept fixed in estimation
apollo_beta = c(mu_log_b_tt    = -3,
sigma_log_b_tt = -0.01,
mu_log_b_tc    = -3,
sigma_log_b_tc = -0.01,
mu_log_b_hw    = -3,
sigma_log_b_hw = -0.01,
mu_log_b_ch    = -3,
sigma_log_b_ch = -0.01)
### Vector with names (in quotes) of parameters to be kept fixed at their starting value in apollo_beta, use apollo_beta_fixed = c() if none
apollo_fixed = c()
### Set parameters for generating draws
apollo_draws = list(
interDrawsType = "halton",
interNDraws    = 500,
interUnifDraws = c(),
interNormDraws = c("draws_tt","draws_tc","draws_hw","draws_ch"),
intraDrawsType = "halton",
intraNDraws    = 0,
intraUnifDraws = c(),
intraNormDraws = c()
)
### Create random parameters
apollo_randCoeff = function(apollo_beta, apollo_inputs){
randcoeff = list()
randcoeff[["b_tt"]] = -exp( mu_log_b_tt + sigma_log_b_tt * draws_tt )
randcoeff[["b_tc"]] = -exp( mu_log_b_tc + sigma_log_b_tc * draws_tc )
randcoeff[["b_hw"]] = -exp( mu_log_b_hw + sigma_log_b_hw * draws_hw )
randcoeff[["b_ch"]] = -exp( mu_log_b_ch + sigma_log_b_ch * draws_ch )
return(randcoeff)
}
apollo_inputs = apollo_validateInputs()
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
### Function initialisation: do not change the following three commands
### Attach inputs and detach after function exit
apollo_attach(apollo_beta, apollo_inputs)
on.exit(apollo_detach(apollo_beta, apollo_inputs))
### Create list of probabilities P
P = list()
### List of utilities: these must use the same names as in mnl_settings, order is irrelevant
V = list()
V[["alt1"]] = b_tt * tt1 + b_tc * tc1 + b_hw * hw1 + b_ch * ch1
V[["alt2"]] = b_tt * tt2 + b_tc * tc2 + b_hw * hw2 + b_ch * ch2
### Define settings for MNL model component
mnl_settings = list(
alternatives  = c(alt1=1, alt2=2),
avail         = list(alt1=1, alt2=1),
choiceVar     = choice,
utilities     = V
)
### Compute probabilities using MNL model
P[["model"]] = apollo_mnl(mnl_settings, functionality)
### Take product across observation for same individual
P = apollo_panelProd(P, apollo_inputs, functionality)
### Average across inter-individual draws
P = apollo_avgInterDraws(P, apollo_inputs, functionality)
### Prepare and return outputs of function
P = apollo_prepareProb(P, apollo_inputs, functionality)
return(P)
}
model = apollo_estimate(apollo_beta, apollo_fixed,apollo_probabilities, apollo_inputs)
apollo_modelOutput(model) #(FORMATTED OUTPUT (TO SCREEN))
apollo_saveOutput(model) #(FORMATTED OUTPUT (TO FILE, using model name))
View(apollo_randCoeff)
knitr::opts_chunk$set(echo = TRUE)
librairy(HSAUR3)
library(HSAUR3)
library(HSAUR3)
?str
plot.design(weightgain)
library(HSAUR3)
data("weightgain", package = "HSAUR3")
weightgain
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), mean)
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), sd)
plot.design(weightgain)
?weightgain
str(weightgain)
library(HSAUR3)
data("weightgain", package = "HSAUR3")
str(weightgain)
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), mean)
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), sd)
plot.design(weightgain)
weightgain
library(HSAUR3)
data("weightgain", package = "HSAUR3")
str(weightgain)
weightgain
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), mean)
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), sd)
plot.design(weightgain)
summary(weightgain)
library(HSAUR3)
data("weightgain", package = "HSAUR3")
str(weightgain) #display internal structure of an object
summary(weightgain)
weightgain
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), mean)
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), sd)
plot.design(weightgain)
str(weightgain) #display internal structure of an object
library(HSAUR3)
data("weightgain", package = "HSAUR3")
str(weightgain) #display internal structure of an object
weightgain
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), mean)
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), sd)
plot.design(weightgain)
?tapply(vector, index, function)
?tapply()
tapply(weightgain$weightgain, weightgain$type, mean)
tapply(weightgain$weightgain, weightgain$source, mean)
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), mean)
library(HSAUR3)
data("weightgain", package = "HSAUR3")
str(weightgain) #display internal structure of an object
weightgain
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), mean) #va regarder la moyenne de poids en fonction de la source (beef/cereal) et du type (high/low protein)
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), sd)
#same mais pour standard variation, ie niveau de viariabilité autour de la moyenne(the bigger the variation, the farthest from the mean)
plot.design(weightgain)
?plot.design
#same mais pour standard variation, ie niveau de viariabilité autour de la moyenne(the bigger the variation, the farthest from the mean)
plot.design(weightgain)
mean(weightgain)
mean(weightgain$weightgain)
library(HSAUR3)
data("weightgain", package = "HSAUR3")
str(weightgain) #display internal structure of an object
weightgain
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), mean) #va regarder la moyenne de poids en fonction de la source (beef/cereal) et du type (high/low protein)
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), sd)
#same mais pour standard variation, ie niveau de viariabilité autour de la moyenne(the bigger the variation, the farthest from the mean)
plot.design(weightgain)
mean(weightgain$weightgain)
#horizontal
library(HSAUR3)
data("weightgain", package = "HSAUR3")
str(weightgain) #display internal structure of an object
weightgain
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), mean) #va regarder la moyenne de poids en fonction de la source (beef/cereal) et du type (high/low protein)
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), sd)
#same mais pour standard variation, ie niveau de viariabilité autour de la moyenne(the bigger the variation, the farthest from the mean)
plot.design(weightgain) #horizontal line = overall mean of weightgain (juste la moyenne de tous les weightgain$weightgain)
mean(weightgain£weightgain)
mean(weightgain$weightgain)
library(HSAUR3)
data("weightgain", package = "HSAUR3")
str(weightgain) #display internal structure of an object
weightgain
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), mean) #va regarder la moyenne de poids en fonction de la source (beef/cereal) et du type (high/low protein)
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), sd)
#same mais pour standard variation, ie niveau de viariabilité autour de la moyenne(the bigger the variation, the farthest from the mean)
plot.design(weightgain) #horizontal line = overall mean of weightgain (juste la moyenne de tous les weightgain$weightgain)
mean(weightgain$weightgain)
#horizontal
?mean
knitr::opts_chunk$set(echo = TRUE)
options(digits=4) #settings to have 4 decimals
install.packages("genetics")
library(genetics)
# Set the working directory to the folder where your file is located
setwd("F:\\COURS\\EPFL\\2023-2024\\Semestre 4 - Master\\Statistical genetics\\Exercices\\Assignment 1")
mean(weightgain$weightgain, weightgain$source)
mean(weightgain$source)
knitr::opts_chunk$set(echo = TRUE)
library(HSAUR3)
data("weightgain", package = "HSAUR3")
str(weightgain) #display internal structure of an object
weightgain
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), mean) #va regarder la moyenne de poids en fonction de la source (beef/cereal) et du type (high/low protein)
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), sd)
#same mais pour standard variation, ie niveau de viariabilité autour de la moyenne(the bigger the variation, the farthest from the mean)
plot.design(weightgain) #horizontal line = overall mean of weightgain (juste la moyenne de tous les weightgain$weightgain)
mean(weightgain$weightgain)
mean(weightgain$source)
#horizontal
knitr::opts_chunk$set(echo = TRUE)
library(HSAUR3)
data("weightgain", package = "HSAUR3")
str(weightgain) #display internal structure of an object
weightgain
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), mean) #va regarder la moyenne de poids en fonction de la source (beef/cereal) et du type (high/low protein)
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), sd)
#same mais pour standard variation, ie niveau de viariabilité autour de la moyenne(the bigger the variation, the farthest from the mean)
plot.design(weightgain) #horizontal line = overall mean of weightgain (juste la moyenne de tous les weightgain$weightgain)
mean(weightgain$weightgain)
#horizontal
tapply(weightgain$weightgain, weightgain$source, mean)
tapply(weightgain$weightgain, weightgain$source, mean)
tapply(weightgain$weightgain, weightgain$type, mean)
tapply(weightgain$weightgain, weightgain$source, mean)
tapply(weightgain$weightgain, weightgain$type, mean)
plot.design(weightgain) #horizontal line = overall mean of weightgain (juste la moyenne de tous les weightgain$weightgain)
tapply(weightgain$weightgain, weightgain$source, mean)
knitr::opts_chunk$set(echo = TRUE)
library(HSAUR3)
data("weightgain", package = "HSAUR3")
str(weightgain) #display internal structure of an object
weightgain
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), mean) #va regarder la moyenne de poids en fonction de la source (beef/cereal) et du type (high/low protein)
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), sd)
#same mais pour standard variation, ie niveau de viariabilité autour de la moyenne(the bigger the variation, the farthest from the mean)
plot.design(weightgain)
#horizontal line = overall mean of weightgain (juste la moyenne de tous les weightgain$weightgain)
#line for beef = mean of weightgain considering beef only, same for cereal, low and high
#to obtain mean for beef and only, do
tapply(weightgain$weightgain, weightgain$source, mean)
mean(weightgain$weightgain)
#horizontal
knitr::opts_chunk$set(echo = TRUE)
library(HSAUR3)
data("weightgain", package = "HSAUR3")
str(weightgain) #display internal structure of an object
weightgain
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), mean) #va regarder la moyenne de poids en fonction de la source (beef/cereal) et du type (high/low protein)
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), sd)
#same mais pour standard variation, ie niveau de viariabilité autour de la moyenne(the bigger the variation, the farthest from the mean)
plot.design(weightgain)
#horizontal line = overall mean of weightgain (juste la moyenne de tous les weightgain$weightgain)
#line for beef = mean of weightgain considering beef only, same for cereal, low and high
#to obtain mean for beef and only, do
tapply(weightgain$weightgain, weightgain$source, mean)
mean(weightgain$weightgain)
#horizontal
knitr::opts_chunk$set(echo = TRUE)
library(HSAUR3)
data("weightgain", package = "HSAUR3")
str(weightgain) #display internal structure of an object
weightgain
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), mean) #va regarder la moyenne de poids en fonction de la source (beef/cereal) et du type (high/low protein)
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), sd)
#same mais pour standard variation, ie niveau de viariabilité autour de la moyenne(the bigger the variation, the farthest from the mean)
plot.design(weightgain)
#horizontal line = overall mean of weightgain (juste la moyenne de tous les weightgain$weightgain)
#line for beef = mean of weightgain considering beef only, same for cereal, low and high
#to obtain mean for beef and only, do
tapply(weightgain$weightgain, weightgain$source, mean)
mean(weightgain$weightgain)
#horizontal
#### *Loading data and primary analysis*
```{r}
knitr::opts_chunk$set(echo = TRUE)
library(HSAUR3)
data("weightgain", package = "HSAUR3")
str(weightgain) #display internal structure of an object
weightgain
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), mean) #va regarder la moyenne de poids en fonction de la source (beef/cereal) et du type (high/low protein)
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), sd)
#same mais pour standard variation, ie niveau de viariabilité autour de la moyenne(the bigger the variation, the farthest from the mean)
plot.design(weightgain)
#horizontal line = overall mean of weightgain (juste la moyenne de tous les weightgain$weightgain)
#line for beef = mean of weightgain considering beef only, same for cereal, low and high
#to obtain mean for beef and only, do
tapply(weightgain$weightgain, weightgain$source, mean)
mean(weightgain$weightgain)
#horizontal
wg.aov <- aov(weightgain ~ source*type, data=weightgain)
summary(wg.aov)
coef(wg.aov)
options("contrasts")
?contrasts
?levels
knitr::opts_chunk$set(echo = TRUE)
library(HSAUR3)
data("weightgain", package = "HSAUR3")
str(weightgain) #display internal structure of an object
weightgain
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), mean) #va regarder la moyenne de poids en fonction de la source (beef/cereal) et du type (high/low protein)
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), sd)
#same mais pour standard variation, ie niveau de viariabilité autour de la moyenne(the bigger the variation, the farthest from the mean)
plot.design(weightgain)
#horizontal line = overall mean of weightgain (juste la moyenne de tous les weightgain$weightgain)
#line for beef = mean of weightgain considering beef only, same for cereal, low and high
#to obtain mean for beef and only, do
tapply(weightgain$weightgain, weightgain$source, mean)
mean(weightgain$weightgain)
#horizontal
wg.aov <- aov(weightgain ~ source*type, data=weightgain)
#weightgain = intercept + b1 * source + b2 * type + b3*source*type
summary(wg.aov)
coef(wg.aov)
#reatment contrasts fit with a model where the coefficient for the first level of a model is set to 0. Thus, the interpretation of a given coefficient is that it estimates the difference between the effect of the first level and the level corresponding to the coefficient. (It is possible to change this if it makes more practical sense to use a different constraint for your problem \- see the help for contrasts. Here, treatment contrasts are fine.)
level(weightgain$source)
knitr::opts_chunk$set(echo = TRUE)
library(HSAUR3)
data("weightgain", package = "HSAUR3")
str(weightgain) #display internal structure of an object
weightgain
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), mean) #va regarder la moyenne de poids en fonction de la source (beef/cereal) et du type (high/low protein)
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), sd)
#same mais pour standard variation, ie niveau de viariabilité autour de la moyenne(the bigger the variation, the farthest from the mean)
plot.design(weightgain)
#horizontal line = overall mean of weightgain (juste la moyenne de tous les weightgain$weightgain)
#line for beef = mean of weightgain considering beef only, same for cereal, low and high
#to obtain mean for beef and only, do
tapply(weightgain$weightgain, weightgain$source, mean)
mean(weightgain$weightgain)
#horizontal
wg.aov <- aov(weightgain ~ source*type, data=weightgain)
#weightgain = intercept + b1 * source + b2 * type + b3*source*type
summary(wg.aov)
coef(wg.aov)
#reatment contrasts fit with a model where the coefficient for the first level of a model is set to 0. Thus, the interpretation of a given coefficient is that it estimates the difference between the effect of the first level and the level corresponding to the coefficient. (It is possible to change this if it makes more practical sense to use a different constraint for your problem \- see the help for contrasts. Here, treatment contrasts are fine.)
levels(weightgain$source)
levels(weightgain$type)
knitr::opts_chunk$set(echo = TRUE)
library(HSAUR3)
data("weightgain", package = "HSAUR3")
str(weightgain) #display internal structure of an object
weightgain
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), mean) #va regarder la moyenne de poids en fonction de la source (beef/cereal) et du type (high/low protein)
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), sd)
#same mais pour standard variation, ie niveau de viariabilité autour de la moyenne(the bigger the variation, the farthest from the mean)
plot.design(weightgain)
#horizontal line = overall mean of weightgain (juste la moyenne de tous les weightgain$weightgain)
#line for beef = mean of weightgain considering beef only, same for cereal, low and high
#to obtain mean for beef and only, do
tapply(weightgain$weightgain, weightgain$source, mean)
mean(weightgain$weightgain)
#horizontal
wg.aov <- aov(weightgain ~ source*type, data=weightgain)
#weightgain = intercept + b1 * source + b2 * type + b3*source*type
summary(wg.aov)
coef(wg.aov)
#reatment contrasts fit with a model where the coefficient for the first level of a model is set to 0. Thus, the interpretation of a given coefficient is that it estimates the difference between the effect of the first level and the level corresponding to the coefficient. (It is possible to change this if it makes more practical sense to use a different constraint for your problem \- see the help for contrasts. Here, treatment contrasts are fine.)
levels(weightgain$source)
levels(weightgain$type)
interaction.plot(weightgain$type, weightgain$source, weightgain$weightgain)
?interaction.plot
interaction.plot(weightgain$type, weightgain$source, weightgain$weightgain, xlab = "type of proteine")
interaction.plot(weightgain$type, weightgain$source, weightgain$weightgain, xlab = "type of proteine", ylab = "overall mean of weightgain")
interaction.plot(weightgain$type, weightgain$source, weightgain$weightgain, trace.label = "source", xlab = "type of proteine", ylab = "overall mean of weightgain")
plot(wg.aov)
knitr::opts_chunk$set(echo = TRUE)
library(HSAUR3)
data("weightgain", package = "HSAUR3")
str(weightgain) #display internal structure of an object
weightgain
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), mean) #va regarder la moyenne de poids en fonction de la source (beef/cereal) et du type (high/low protein)
tapply(weightgain$weightgain, list(weightgain$source, weightgain$type), sd)
#same mais pour standard variation, ie niveau de viariabilité autour de la moyenne(the bigger the variation, the farthest from the mean)
plot.design(weightgain)
#horizontal line = overall mean of weightgain (juste la moyenne de tous les weightgain$weightgain)
#line for beef = mean of weightgain considering beef only, same for cereal, low and high
#to obtain mean for beef and only, do
tapply(weightgain$weightgain, weightgain$source, mean)
mean(weightgain$weightgain)
#horizontal
wg.aov <- aov(weightgain ~ source*type, data=weightgain)
#weightgain = intercept + b1 * source + b2 * type + b3*source*type
summary(wg.aov)
coef(wg.aov)
#reatment contrasts fit with a model where the coefficient for the first level of a model is set to 0. Thus, the interpretation of a given coefficient is that it estimates the difference between the effect of the first level and the level corresponding to the coefficient. (It is possible to change this if it makes more practical sense to use a different constraint for your problem \- see the help for contrasts. Here, treatment contrasts are fine.)
levels(weightgain$source)
levels(weightgain$type) #gives the different levels of each factors~, is ordered by alphabetic order but can change it with certain commands
interaction.plot(weightgain$type, weightgain$source, weightgain$weightgain, trace.label = "source", xlab = "type of protein", ylab = "overall mean of weightgain")
layout(matrix(1:4,ncol=2))
plot(wg.aov)
<p style="text-align: center;">Blabla</p>
<p style="text-align: center;"> Weightgain = $\beta_0$ + $\beta_1 \cdot$ sourceCereal + $\beta_2 \cdot$ typeLow +$\beta_3\cdot$sourceCereal$\cdot$typeLow</p>
knitr::opts_chunk$set(echo = TRUE)
### Clear memory
rm(list = ls())
### Load Apollo library
library(apollo)
### Initialise code
apollo_initialise()
### Set core controls
apollo_control = list(
modelName       = "MMNL_preference_space",
modelDescr      = "Mixed logit model on Swiss route choice data, uncorrelated Lognormals in preference space",
indivID         = "ID",
nCores          = 4,
outputDirectory = "output"
)
### Loading data from package
### if data is to be loaded from a file (e.g. called data.csv),
### the code would be: database = read.csv("data.csv",header=TRUE)
database = apollo_swissRouteChoiceData
### for data dictionary, use ?apollo_swissRouteChoiceData
### Note this is unlabelled data, so we are doing this for an illustration of cheap vs expensive
### Define settings for analysis of choice data to be conducted prior to model estimation
choiceAnalysis_settings <- list(
alternatives = c(cheap=1, expensive=2),
choiceVar    = (1*((database$choice==1)*(database$tc1<=database$tc2)+(database$choice==2)*(database$tc1>=database$tc2))
+2*((database$choice==1)*(database$tc1>=database$tc2)+(database$choice==2)*(database$tc1<=database$tc2))),
explanators  = database[,c("car_availability","hh_inc_abs","business")]
)
### Run function to analyse choice data
apollo_choiceAnalysis(choiceAnalysis_settings, apollo_control, database)
### Vector of parameters, including any that are kept fixed in estimation
apollo_beta = c(mu_log_b_tt    = -3,
sigma_log_b_tt = -0.01,
mu_log_b_tc    = -3,
sigma_log_b_tc = -0.01,
mu_log_b_hw    = -3,
sigma_log_b_hw = -0.01,
mu_log_b_ch    = -3,
sigma_log_b_ch = -0.01)
### Vector with names (in quotes) of parameters to be kept fixed at their starting value in apollo_beta, use apollo_beta_fixed = c() if none
apollo_fixed = c()
### Set parameters for generating draws
apollo_draws = list(
interDrawsType = "halton",
interNDraws    = 500,
interUnifDraws = c(),
interNormDraws = c("draws_tt","draws_tc","draws_hw","draws_ch"),
intraDrawsType = "halton",
intraNDraws    = 0,
intraUnifDraws = c(),
intraNormDraws = c()
)
### Create random parameters
apollo_randCoeff = function(apollo_beta, apollo_inputs){
randcoeff = list()
randcoeff[["b_tt"]] = -exp( mu_log_b_tt + sigma_log_b_tt * draws_tt )
randcoeff[["b_tc"]] = -exp( mu_log_b_tc + sigma_log_b_tc * draws_tc )
randcoeff[["b_hw"]] = -exp( mu_log_b_hw + sigma_log_b_hw * draws_hw )
randcoeff[["b_ch"]] = -exp( mu_log_b_ch + sigma_log_b_ch * draws_ch )
return(randcoeff)
}
apollo_inputs = apollo_validateInputs()
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
### Function initialisation: do not change the following three commands
### Attach inputs and detach after function exit
apollo_attach(apollo_beta, apollo_inputs)
on.exit(apollo_detach(apollo_beta, apollo_inputs))
### Create list of probabilities P
P = list()
### List of utilities: these must use the same names as in mnl_settings, order is irrelevant
V = list()
V[["alt1"]] = b_tt * tt1 + b_tc * tc1 + b_hw * hw1 + b_ch * ch1
V[["alt2"]] = b_tt * tt2 + b_tc * tc2 + b_hw * hw2 + b_ch * ch2
### Define settings for MNL model component
mnl_settings = list(
alternatives  = c(alt1=1, alt2=2),
avail         = list(alt1=1, alt2=1),
choiceVar     = choice,
utilities     = V
)
### Compute probabilities using MNL model
P[["model"]] = apollo_mnl(mnl_settings, functionality)
### Take product across observation for same individual
P = apollo_panelProd(P, apollo_inputs, functionality)
### Average across inter-individual draws
P = apollo_avgInterDraws(P, apollo_inputs, functionality)
### Prepare and return outputs of function
P = apollo_prepareProb(P, apollo_inputs, functionality)
return(P)
}
model = apollo_estimate(apollo_beta, apollo_fixed,apollo_probabilities, apollo_inputs)
apollo_inputs = apollo_validateInputs()
### Set parameters for generating draws
apollo_draws = list(
interDrawsType = "halton",
interNDraws    = 500,
interUnifDraws = c(),
interNormDraws = c("draws_tt","draws_tc","draws_hw","draws_ch"),
intraDrawsType = "halton",
intraNDraws    = 0,
intraUnifDraws = c(),
intraNormDraws = c()
)
### Create random parameters
apollo_randCoeff = function(apollo_beta, apollo_inputs){
randcoeff = list()
randcoeff[["b_tt"]] = -exp( mu_log_b_tt + sigma_log_b_tt * draws_tt )
randcoeff[["b_tc"]] = -exp( mu_log_b_tc + sigma_log_b_tc * draws_tc )
randcoeff[["b_hw"]] = -exp( mu_log_b_hw + sigma_log_b_hw * draws_hw )
randcoeff[["b_ch"]] = -exp( mu_log_b_ch + sigma_log_b_ch * draws_ch )
return(randcoeff)
}
View(apollo_randCoeff)
