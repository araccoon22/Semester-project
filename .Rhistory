bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
library(HSAUR3)
data("clouds", package = "HSAUR3")
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 1))
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
?clouds
?boxplot
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
#boxplot for dichotomous variables (discrete?)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 1)) #permet d'afficher les prochains plots dans un "tableau" 1 row, 2 columns)
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
#scatterplots for continuous variables
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
summary(clouds.lm)
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
#boxplot for dichotomous variables (discrete?)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 1)) #permet d'afficher les prochains plots dans un "tableau" 1 row, 2 columns)
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
#scatterplots for continuous variables
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
summary(clouds.lm)
coef(clouds.lm)
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
#boxplot for dichotomous variables (discrete?)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 1)) #permet d'afficher les prochains plots dans un "tableau" 1 row, 2 columns)
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
#scatterplots for continuous variables
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
summary(clouds.lm)
coef(clouds.lm)
summary(clouds.lm)
coef(clouds.lm)
```
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
#boxplot for dichotomous variables (discrete?)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 1)) #permet d'afficher les prochains plots dans un "tableau" 1 row, 2 columns)
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
#scatterplots for continuous variables
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
summary(clouds.lm)
coef(clouds.lm)
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
#boxplot for dichotomous variables (discrete?)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 1)) #permet d'afficher les prochains plots dans un "tableau" 1 row, 2 columns)
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
#scatterplots for continuous variables
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
summary(clouds.lm)
coef(clouds.lm)
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
#boxplot for dichotomous variables (discrete?)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 1)) #permet d'afficher les prochains plots dans un "tableau" 1 row, 2 columns)
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
#scatterplots for continuous variables
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
summary(clouds.lm)
coef(clouds.lm)
clouds.fitted <- fitted(clouds.lm)
clouds.resid <- residuals(clouds.lm)
clouds.fitted <- fitted(clouds.lm)
residuals(clouds.lm)
```
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
#boxplot for dichotomous variables (discrete?)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 1)) #permet d'afficher les prochains plots dans un "tableau" 1 row, 2 columns)
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
#scatterplots for continuous variables
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
summary(clouds.lm)
coef(clouds.lm)
clouds.resid <- residuals(clouds.lm)
clouds.fitted <- fitted(clouds.lm)
#How do I plot these ????
layout(1)
psymb <- as.numeric(clouds$seeding)
plot(rainfall ~ sne, data = clouds, pch = psymb, xlab = "S-Ne criterion")
abline(lm(rainfall ~ sne, data = clouds, subset = seeding == "no"))
abline(lm(rainfall ~ sne, data = clouds, subset = seeding == "yes"), lty = 2)
legend("topright", legend = c("No seeding", "Seeding"), pch = 1:2, lty = 1:2, bty = "n")
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
#boxplot for dichotomous variables (discrete?)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 1)) #permet d'afficher les prochains plots dans un "tableau" 1 row, 2 columns)
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
#scatterplots for continuous variables
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
summary(clouds.lm)
coef(clouds.lm)
clouds.resid <- residuals(clouds.lm)
clouds.fitted <- fitted(clouds.lm)
#How do I plot these ????
layout(1)
psymb <- as.numeric(clouds$seeding)
plot(rainfall ~ sne, data = clouds, pch = psymb, xlab = "S-Ne criterion")
abline(lm(rainfall ~ sne, data = clouds, subset = seeding == "no"))
abline(lm(rainfall ~ sne, data = clouds, subset = seeding == "yes"), lty = 2)
legend("topright", legend = c("No seeding", "Seeding"), pch = 1:2, lty = 1:2, bty = "n")
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
#boxplot for dichotomous variables (discrete?)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 1)) #permet d'afficher les prochains plots dans un "tableau" 1 row, 2 columns)
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
#scatterplots for continuous variables
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
summary(clouds.lm)
coef(clouds.lm)
clouds.resid <- residuals(clouds.lm)
clouds.fitted <- fitted(clouds.lm)
#How do I plot these ????
layout(1)
psymb <- as.numeric(clouds$seeding)
plot(rainfall ~ sne, data = clouds, pch = psymb, xlab = "S-Ne criterion")
abline(lm(rainfall ~ sne, data = clouds, subset = seeding == "no"))
abline(lm(rainfall ~ sne, data = clouds, subset = seeding == "yes"), lty = 2)
legend("topright", legend = c("No seeding", "Seeding"), pch = 1:2, lty = 1:2, bty = "n")
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
#boxplot for dichotomous variables (discrete?)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 1)) #permet d'afficher les prochains plots dans un "tableau" 1 row, 2 columns)
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
#scatterplots for continuous variables
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
summary(clouds.lm)
coef(clouds.lm)
clouds.resid <- residuals(clouds.lm)
clouds.fitted <- fitted(clouds.lm)
#How do I plot these ????
layout(1)
psymb <- as.numeric(clouds$seeding)
plot(rainfall ~ sne, data = clouds, pch = psymb, xlab = "S-Ne criterion")
abline(lm(rainfall ~ sne, data = clouds, subset = seeding == "no"))
abline(lm(rainfall ~ sne, data = clouds, subset = seeding == "yes"), lty = 2)
legend("topright", legend = c("No seeding", "Seeding"), pch = 1:2, lty = 1:2, bty = "n")
knitr::opts_chunk$set(echo = TRUE)
### Clear memory
rm(list = ls())
### Load Apollo library
library(apollo)
### Initialise code
apollo_initialise()
### Set core controls
apollo_control = list(
modelName       = "MMNL_preference_space",
modelDescr      = "Mixed logit model on Swiss route choice data, uncorrelated Lognormals in preference space",
indivID         = "ID",
nCores          = 4,
outputDirectory = "output"
)
### Loading data from package
### if data is to be loaded from a file (e.g. called data.csv),
### the code would be: database = read.csv("data.csv",header=TRUE)
database = apollo_swissRouteChoiceData
### for data dictionary, use ?apollo_swissRouteChoiceData
### Note this is unlabelled data, so we are doing this for an illustration of cheap vs expensive
### Define settings for analysis of choice data to be conducted prior to model estimation
choiceAnalysis_settings <- list(
alternatives = c(cheap=1, expensive=2),
choiceVar    = (1*((database$choice==1)*(database$tc1<=database$tc2)+(database$choice==2)*(database$tc1>=database$tc2))
+2*((database$choice==1)*(database$tc1>=database$tc2)+(database$choice==2)*(database$tc1<=database$tc2))),
explanators  = database[,c("car_availability","hh_inc_abs","business")]
)
### Run function to analyse choice data
apollo_choiceAnalysis(choiceAnalysis_settings, apollo_control, database)
### Vector of parameters, including any that are kept fixed in estimation
apollo_beta = c(mu_log_b_tt    = -3,
sigma_log_b_tt = -0.01,
mu_log_b_tc    = -3,
sigma_log_b_tc = -0.01,
mu_log_b_hw    = -3,
sigma_log_b_hw = -0.01,
mu_log_b_ch    = -3,
sigma_log_b_ch = -0.01)
### Vector with names (in quotes) of parameters to be kept fixed at their starting value in apollo_beta, use apollo_beta_fixed = c() if none
apollo_fixed = c()
# ################################################################# #
#### DEFINE RANDOM COMPONENTS                                    ####
# ################################################################# #
### Set parameters for generating draws
apollo_draws = list(
interDrawsType = "halton",
interNDraws    = 500,
interUnifDraws = c(),
interNormDraws = c("draws_tt","draws_tc","draws_hw","draws_ch"),
intraDrawsType = "halton",
intraNDraws    = 0,
intraUnifDraws = c(),
intraNormDraws = c()
)
### Create random parameters
apollo_randCoeff = function(apollo_beta, apollo_inputs){
randcoeff = list()
randcoeff[["b_tt"]] = -exp( mu_log_b_tt + sigma_log_b_tt * draws_tt )
randcoeff[["b_tc"]] = -exp( mu_log_b_tc + sigma_log_b_tc * draws_tc )
randcoeff[["b_hw"]] = -exp( mu_log_b_hw + sigma_log_b_hw * draws_hw )
randcoeff[["b_ch"]] = -exp( mu_log_b_ch + sigma_log_b_ch * draws_ch )
return(randcoeff)
}
apollo_inputs = apollo_validateInputs()
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
### Function initialisation: do not change the following three commands
### Attach inputs and detach after function exit
apollo_attach(apollo_beta, apollo_inputs)
on.exit(apollo_detach(apollo_beta, apollo_inputs))
### Create list of probabilities P
P = list()
### List of utilities: these must use the same names as in mnl_settings, order is irrelevant
V = list()
V[["alt1"]] = b_tt * tt1 + b_tc * tc1 + b_hw * hw1 + b_ch * ch1
V[["alt2"]] = b_tt * tt2 + b_tc * tc2 + b_hw * hw2 + b_ch * ch2
### Define settings for MNL model component
mnl_settings = list(
alternatives  = c(alt1=1, alt2=2),
avail         = list(alt1=1, alt2=1),
choiceVar     = choice,
utilities     = V
)
### Compute probabilities using MNL model
P[["model"]] = apollo_mnl(mnl_settings, functionality)
### Take product across observation for same individual
P = apollo_panelProd(P, apollo_inputs, functionality)
### Average across inter-individual draws
P = apollo_avgInterDraws(P, apollo_inputs, functionality)
### Prepare and return outputs of function
P = apollo_prepareProb(P, apollo_inputs, functionality)
return(P)
}
model = apollo_estimate(apollo_beta, apollo_fixed,apollo_probabilities, apollo_inputs)
