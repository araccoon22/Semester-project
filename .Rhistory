Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 2))
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 2))
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 2))
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
layout(matrix(1:4, nrow = 2))
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 2))
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
library(HSAUR3)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 2))
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
library(HSAUR3)
data("clouds", package = "HSAUR3")
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 1))
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
?clouds
?boxplot
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
#boxplot for dichotomous variables (discrete?)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 1)) #permet d'afficher les prochains plots dans un "tableau" 1 row, 2 columns)
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
#scatterplots for continuous variables
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
summary(clouds.lm)
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
#boxplot for dichotomous variables (discrete?)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 1)) #permet d'afficher les prochains plots dans un "tableau" 1 row, 2 columns)
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
#scatterplots for continuous variables
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
summary(clouds.lm)
coef(clouds.lm)
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
#boxplot for dichotomous variables (discrete?)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 1)) #permet d'afficher les prochains plots dans un "tableau" 1 row, 2 columns)
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
#scatterplots for continuous variables
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
summary(clouds.lm)
coef(clouds.lm)
summary(clouds.lm)
coef(clouds.lm)
```
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
#boxplot for dichotomous variables (discrete?)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 1)) #permet d'afficher les prochains plots dans un "tableau" 1 row, 2 columns)
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
#scatterplots for continuous variables
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
summary(clouds.lm)
coef(clouds.lm)
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
#boxplot for dichotomous variables (discrete?)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 1)) #permet d'afficher les prochains plots dans un "tableau" 1 row, 2 columns)
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
#scatterplots for continuous variables
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
summary(clouds.lm)
coef(clouds.lm)
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
#boxplot for dichotomous variables (discrete?)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 1)) #permet d'afficher les prochains plots dans un "tableau" 1 row, 2 columns)
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
#scatterplots for continuous variables
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
summary(clouds.lm)
coef(clouds.lm)
clouds.fitted <- fitted(clouds.lm)
clouds.resid <- residuals(clouds.lm)
clouds.fitted <- fitted(clouds.lm)
residuals(clouds.lm)
```
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
#boxplot for dichotomous variables (discrete?)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 1)) #permet d'afficher les prochains plots dans un "tableau" 1 row, 2 columns)
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
#scatterplots for continuous variables
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
summary(clouds.lm)
coef(clouds.lm)
clouds.resid <- residuals(clouds.lm)
clouds.fitted <- fitted(clouds.lm)
#How do I plot these ????
layout(1)
psymb <- as.numeric(clouds$seeding)
plot(rainfall ~ sne, data = clouds, pch = psymb, xlab = "S-Ne criterion")
abline(lm(rainfall ~ sne, data = clouds, subset = seeding == "no"))
abline(lm(rainfall ~ sne, data = clouds, subset = seeding == "yes"), lty = 2)
legend("topright", legend = c("No seeding", "Seeding"), pch = 1:2, lty = 1:2, bty = "n")
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
#boxplot for dichotomous variables (discrete?)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 1)) #permet d'afficher les prochains plots dans un "tableau" 1 row, 2 columns)
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
#scatterplots for continuous variables
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
summary(clouds.lm)
coef(clouds.lm)
clouds.resid <- residuals(clouds.lm)
clouds.fitted <- fitted(clouds.lm)
#How do I plot these ????
layout(1)
psymb <- as.numeric(clouds$seeding)
plot(rainfall ~ sne, data = clouds, pch = psymb, xlab = "S-Ne criterion")
abline(lm(rainfall ~ sne, data = clouds, subset = seeding == "no"))
abline(lm(rainfall ~ sne, data = clouds, subset = seeding == "yes"), lty = 2)
legend("topright", legend = c("No seeding", "Seeding"), pch = 1:2, lty = 1:2, bty = "n")
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
#boxplot for dichotomous variables (discrete?)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 1)) #permet d'afficher les prochains plots dans un "tableau" 1 row, 2 columns)
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
#scatterplots for continuous variables
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
summary(clouds.lm)
coef(clouds.lm)
clouds.resid <- residuals(clouds.lm)
clouds.fitted <- fitted(clouds.lm)
#How do I plot these ????
layout(1)
psymb <- as.numeric(clouds$seeding)
plot(rainfall ~ sne, data = clouds, pch = psymb, xlab = "S-Ne criterion")
abline(lm(rainfall ~ sne, data = clouds, subset = seeding == "no"))
abline(lm(rainfall ~ sne, data = clouds, subset = seeding == "yes"), lty = 2)
legend("topright", legend = c("No seeding", "Seeding"), pch = 1:2, lty = 1:2, bty = "n")
knitr::opts_chunk$set(echo = TRUE)
library(gamair)
data(hubble)
names(hubble) #gives the name of the columns in the table
plot(hubble$x, hubble$y, main = "Scatter plot of the Hubble data", xlab="Distance", ylab="Velovity")
#Fitting a linear model (without intercept)
hmod <- lm(y ~ x - 1, data=hubble) #this means y = ax
b1 <- coef(hmod) #estimated model coefficient, nous donne combien devrait valoir a pour avoir la meilleure approximation linéaire entre y et x
layout(matrix(1:2,ncol=2))
plot(y ~ x, data = hubble)
abline(hmod) #adds straight lines to the plots
plot(hmod, which = 1) #ligne en tretillet =hmod, points= #data, ligne rouge = comment résidus varient
#gives the residual vs fitted values: When conducting a residual analysis, a        "residuals versus fits plot" is the most frequently created plot. It is a scatter       plot of residuals on the y axis and fitted values (estimated responses) on the x        axis. The plot is used to detect non-linearity, unequal error variances, and            outliers.
#approximating age of the universe:
Hubble_const <- b1 / (3.09 * (10^19))*360
age_universe <- 1/Hubble_const
age_universe
library(HSAUR3)
#boxplot for dichotomous variables (discrete?)
data("clouds", package = "HSAUR3")
layout(matrix(1:2, nrow = 1)) #permet d'afficher les prochains plots dans un "tableau" 1 row, 2 columns)
boxplot(rainfall ~ seeding, data = clouds, ylab = "Rainfall", xlab = "Seeding")
bxpecho <- boxplot(rainfall ~ echomotion, data = clouds, ylab = "Rainfall", xlab = "Echo Motion")
#scatterplots for continuous variables
layout(matrix(1:4, nrow = 2))
plot(rainfall ~ time, data = clouds)
plot(rainfall ~ cloudcover, data = clouds)
plot(rainfall ~ sne, data = clouds)
plot(rainfall ~ prewetness, data = clouds)
clouds.formula <- rainfall ~ seeding + seeding:(sne + cloudcover + prewetness + echomotion) + time
clouds.lm <- lm(clouds.formula, data = clouds)
summary(clouds.lm)
coef(clouds.lm)
clouds.resid <- residuals(clouds.lm)
clouds.fitted <- fitted(clouds.lm)
#How do I plot these ????
layout(1)
psymb <- as.numeric(clouds$seeding)
plot(rainfall ~ sne, data = clouds, pch = psymb, xlab = "S-Ne criterion")
abline(lm(rainfall ~ sne, data = clouds, subset = seeding == "no"))
abline(lm(rainfall ~ sne, data = clouds, subset = seeding == "yes"), lty = 2)
legend("topright", legend = c("No seeding", "Seeding"), pch = 1:2, lty = 1:2, bty = "n")
