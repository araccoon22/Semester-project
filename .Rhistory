interNDraws    = 100,
interUnifDraws = c(),
interNormDraws = c("draws"),  #Standard Normal dist draws
intraDrawsType = "halton",
intraNDraws    = 0,
intraUnifDraws = c(),
intraNormDraws = c()
)
### Create random parameters
apollo_randCoeff = function(apollo_beta, apollo_inputs){
randcoeff = list()
randcoeff[["B_TIME_RND"]] = B_TIME + B_TIME_S * draws
return(randcoeff)
}
### Set parameters for generating draws
apollo_draws = list(
interDrawsType = "halton",
interNDraws    = 100,
interUnifDraws = c(),
interNormDraws = c("draws"),  #Standard Normal dist draws
intraDrawsType = "halton",
intraNDraws    = 0,
intraUnifDraws = c(),
intraNormDraws = c()
)
### Create random parameters
apollo_randCoeff = function(apollo_beta, apollo_inputs){
randcoeff = list()
randcoeff[["B_TIME_RND"]] = B_TIME + B_TIME_S * draws
return(randcoeff)
}
apollo_inputs = apollo_validateInputs()
knitr::opts_chunk$set(echo = TRUE)
### Load Apollo library
library(apollo)
#load dplyr library
library(dplyr)
### Initialise code
apollo_initialise()
### Set core controls
apollo_control = list(
modelName       = "MMNL_preference_space",
modelDescr      = "Mixed logit model on Swiss route choice data, uncorrelated Lognormals in preference space",
indivID         = "ID",
nCores          = 4,
outputDirectory = "output"
)
file_path <- "C:/Users/alexi/Desktop/GITS/Semester-project/Data/swissmetro.dat"
db_swissmetro = read.table(file_path, header = TRUE)
exclude <- with(db_swissmetro, ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0)
db_swissmetro <- subset(db_swissmetro, !exclude) #This makes us go from  10,728 observations (rows) to 6,768
attach(db_swissmetro) #To not refere to database_swissmetro everytime
#We define the new variables that we will use later and add them directly to the database
db_swissmetro$SM_COST <- SM_CO * (GA == 0)
db_swissmetro$TRAIN_COST <- TRAIN_CO * (GA == 0)
db_swissmetro$CAR_AV_SP <- CAR_AV * (SP != 0)
db_swissmetro$TRAIN_AV_SP <- TRAIN_AV * (SP != 0)
db_swissmetro$TRAIN_TT_SCALED <- TRAIN_TT / 100
db_swissmetro$TRAIN_COST_SCALED <- TRAIN_COST / 100
db_swissmetro$SM_TT_SCALED <- SM_TT / 100
db_swissmetro$CAR_TT_SCALED<- CAR_TT / 100
db_swissmetro$CAR_CO_SCALED <- CAR_CO / 100
db_swissmetro$SM_COST_SCALED <- db_swissmetro$SM_COST / 100 #idk why it doesnt rescale the SM_COST when exluding some of the data
#This makes us go from  28 variables (columns) to 38
db_swissmetro
### Vector of parameters, including any that are kept fixed in estimation
apollo_beta = c(ASC_CAR        = 0,
ASC_TRAIN      = 0,
ASC_SM         = 0,
B_COST         = 0,
B_TIME         = 0,
B_TIME_S       = 1)
### Vector with names (in quotes) of parameters to be kept fixed at their starting value in apollo_beta, use apollo_beta_fixed = c() if none
apollo_fixed = c("ASC_SM")
### Set parameters for generating draws
apollo_draws = list(
interDrawsType = "halton",
interNDraws    = 100,
interUnifDraws = c(),
interNormDraws = c("draws"),  #Standard Normal dist draws
intraDrawsType = "halton",
intraNDraws    = 0,
intraUnifDraws = c(),
intraNormDraws = c()
)
### Create random parameters
apollo_randCoeff = function(apollo_beta, apollo_inputs){
randcoeff = list()
randcoeff[["B_TIME_RND"]] = B_TIME + B_TIME_S * draws
return(randcoeff)
}
apollo_inputs = apollo_validateInputs()
### Clear memory
rm(list = ls())
### Load Apollo library
library(apollo)
#load dplyr library
library(dplyr)
### Initialise code
apollo_initialise()
### Set core controls
apollo_control = list(
modelName       = "Swissmetro",
modelDescr      = "Mixed logit model on Swissmetro, uncorrelated Lognormals in preference space",
indivID         = "ID",
nCores          = 4,
outputDirectory = "output"
)
apollo_inputs = apollo_validateInputs()
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
### Function initialisation: do not change the following three commands
### Attach inputs and detach after function exit
apollo_attach(apollo_beta, apollo_inputs)
on.exit(apollo_detach(apollo_beta, apollo_inputs))
### Create list of probabilities P
P = list()
### List of utilities: these must use the same names as in mnl_settings, order is irrelevant
V = list()
V[["alt1"]] = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
V[["alt2"]] = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
V[["alt3"]] = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
### Define settings for MNL model component
mnl_settings = list(
alternatives  = c(alt1=1, alt2=2, alt3=3),
avail         = list(alt1=1, alt2=1,alt3=3),
choiceVar     = CHOICE,
utilities     = V
)
### Compute probabilities using MNL model
P[["model"]] = apollo_mnl(mnl_settings, functionality)
### Take product across observation for same individual
P = apollo_panelProd(P, apollo_inputs, functionality)
### Average across inter-individual draws
P = apollo_avgInterDraws(P, apollo_inputs, functionality)
### Prepare and return outputs of function
P = apollo_prepareProb(P, apollo_inputs, functionality)
return(P)
}
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
### Function initialisation: do not change the following three commands
### Attach inputs and detach after function exit
apollo_attach(apollo_beta, apollo_inputs)
on.exit(apollo_detach(apollo_beta, apollo_inputs))
### Create list of probabilities P
P = list()
### List of utilities: these must use the same names as in mnl_settings, order is irrelevant
V = list()
V[["alt1"]] = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
V[["alt2"]] = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
V[["alt3"]] = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
### Define settings for MNL model component
mnl_settings = list(
alternatives  = c(alt1=1, alt2=2, alt3=3),
avail         = list(alt1=1, alt2=1,alt3=3),
choiceVar     = CHOICE,
utilities     = V
)
### Compute probabilities using MNL model
P[["model"]] = apollo_mnl(mnl_settings, functionality)
### Take product across observation for same individual
P = apollo_panelProd(P, apollo_inputs, functionality)
### Average across inter-individual draws
P = apollo_avgInterDraws(P, apollo_inputs, functionality)
### Prepare and return outputs of function
P = apollo_prepareProb(P, apollo_inputs, functionality)
return(P)
}
### Compute probabilities using MNL model
P[["model"]] = apollo_mnl(mnl_settings, functionality)
### Define settings for MNL model component
mnl_settings = list(
alternatives  = c(alt1=1, alt2=2, alt3=3),
avail         = list(TRAIN_AV=1, SM_AV=2, CAR_AV=3),
choiceVar     = CHOICE,
utilities     = V
)
### Define settings for MNL model component
mnl_settings = list(
alternatives  = c(alt1=1, alt2=2, alt3=3),
avail         = list(TRAIN_AV=1, SM_AV=2, CAR_AV=3),
choiceVar     = CHOICE,
utilities     = V
)
knitr::opts_chunk$set(echo = TRUE)
### Clear memory
rm(list = ls())
### Load Apollo library
library(apollo)
#load dplyr library
library(dplyr)
### Initialise code
apollo_initialise()
### Set core controls
apollo_control = list(
modelName       = "Swissmetro",
modelDescr      = "Mixed logit model on Swissmetro, uncorrelated Lognormals in preference space",
indivID         = "ID",
nCores          = 4,
outputDirectory = "output"
)
file_path <- "C:/Users/alexi/Desktop/GITS/Semester-project/Data/swissmetro.dat"
db_swissmetro = read.table(file_path, header = TRUE)
exclude <- with(db_swissmetro, ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0)
db_swissmetro <- subset(db_swissmetro, !exclude) #This makes us go from  10,728 observations (rows) to 6,768
attach(db_swissmetro) #To not refere to database_swissmetro everytime
#We define the new variables that we will use later and add them directly to the database
db_swissmetro$SM_COST <- SM_CO * (GA == 0)
db_swissmetro$TRAIN_COST <- TRAIN_CO * (GA == 0)
db_swissmetro$CAR_AV_SP <- CAR_AV * (SP != 0)
db_swissmetro$TRAIN_AV_SP <- TRAIN_AV * (SP != 0)
db_swissmetro$TRAIN_TT_SCALED <- TRAIN_TT / 100
db_swissmetro$TRAIN_COST_SCALED <- TRAIN_COST / 100
knitr::opts_chunk$set(echo = TRUE)
### Clear memory
rm(list = ls())
### Load Apollo library
library(apollo)
#load dplyr library
library(dplyr)
### Initialise code
apollo_initialise()
### Set core controls
apollo_control = list(
modelName       = "Swissmetro",
modelDescr      = "Mixed logit model on Swissmetro, uncorrelated Lognormals in preference space",
indivID         = "ID",
nCores          = 4,
outputDirectory = "output"
)
file_path <- "C:/Users/alexi/Desktop/GITS/Semester-project/Data/swissmetro.dat"
db_swissmetro = read.table(file_path, header = TRUE)
exclude <- with(db_swissmetro, ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0)
db_swissmetro <- subset(db_swissmetro, !exclude) #This makes us go from  10,728 observations (rows) to 6,768
attach(db_swissmetro) #To not refere to database_swissmetro everytime
#We define the new variables that we will use later and add them directly to the database
db_swissmetro$SM_COST <- SM_CO * (GA == 0)
db_swissmetro$TRAIN_COST <- TRAIN_CO * (GA == 0)
db_swissmetro$CAR_AV_SP <- CAR_AV * (SP != 0)
db_swissmetro$TRAIN_AV_SP <- TRAIN_AV * (SP != 0)
db_swissmetro$TRAIN_TT_SCALED <- TRAIN_TT / 100
db_swissmetro$TRAIN_COST_SCALED <- TRAIN_COST / 100
#To not refere to database_swissmetro everytime
#We define the new variables that we will use later and add them directly to the database
db_swissmetro$SM_COST <- db_swissmetro$SM_CO * (GA == 0)
db_swissmetro$TRAIN_COST <- db_swissmetro$TRAIN_CO * (GA == 0)
db_swissmetro$CAR_AV_SP <- db_swissmetro$CAR_AV * (SP != 0)
db_swissmetro$TRAIN_AV_SP <- db_swissmetro$TRAIN_AV * (SP != 0)
db_swissmetro$TRAIN_TT_SCALED <- db_swissmetro$TRAIN_TT / 100
db_swissmetro$TRAIN_COST_SCALED <- db_swissmetro$TRAIN_COST / 100
db_swissmetro$SM_TT_SCALED <- db_swissmetro$SM_TT / 100
db_swissmetro$CAR_TT_SCALED<- db_swissmetro$CAR_TT / 100
db_swissmetro$CAR_CO_SCALED <- db_swissmetro$CAR_CO / 100
db_swissmetro$SM_COST_SCALED <- db_swissmetro$SM_COST / 100 #idk why it doesnt rescale the SM_COST when exluding some of the data
#This makes us go from  28 variables (columns) to 38
db_swissmetro
### Vector of parameters, including any that are kept fixed in estimation
apollo_beta = c(ASC_CAR        = 0,
ASC_TRAIN      = 0,
ASC_SM         = 0,
B_COST         = 0,
B_TIME         = 0,
B_TIME_S       = 1)
### Vector with names (in quotes) of parameters to be kept fixed at their starting value in apollo_beta, use apollo_beta_fixed = c() if none
apollo_fixed = c("ASC_SM")
### Set parameters for generating draws
apollo_draws = list(
interDrawsType = "halton",
interNDraws    = 100,
interUnifDraws = c(),
interNormDraws = c("draws"),  #Standard Normal dist draws
intraDrawsType = "halton",
intraNDraws    = 0,
intraUnifDraws = c(),
intraNormDraws = c()
)
### Create random parameters
apollo_randCoeff = function(apollo_beta, apollo_inputs){
randcoeff = list()
randcoeff[["B_TIME_RND"]] = B_TIME + B_TIME_S * draws
return(randcoeff)
}
apollo_inputs = apollo_validateInputs()
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
### Function initialisation: do not change the following three commands
### Attach inputs and detach after function exit
apollo_attach(apollo_beta, apollo_inputs)
on.exit(apollo_detach(apollo_beta, apollo_inputs))
### Create list of probabilities P
P = list()
### List of utilities: these must use the same names as in mnl_settings, order is irrelevant
V = list()
V[["alt1"]] = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
V[["alt2"]] = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
V[["alt3"]] = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
### Define settings for MNL model component
mnl_settings = list(
alternatives  = c(alt1=1, alt2=2, alt3=3),
avail         = list(TRAIN_AV=1, SM_AV=2, CAR_AV=3),
choiceVar     = CHOICE,
utilities     = V
)
### Compute probabilities using MNL model
P[["model"]] = apollo_mnl(mnl_settings, functionality)
### Take product across observation for same individual
P = apollo_panelProd(P, apollo_inputs, functionality)
### Average across inter-individual draws
P = apollo_avgInterDraws(P, apollo_inputs, functionality)
### Prepare and return outputs of function
P = apollo_prepareProb(P, apollo_inputs, functionality)
return(P)
}
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
### Function initialisation: do not change the following three commands
### Attach inputs and detach after function exit
apollo_attach(apollo_beta, apollo_inputs)
on.exit(apollo_detach(apollo_beta, apollo_inputs))
### Create list of probabilities P
P = list()
### List of utilities: these must use the same names as in mnl_settings, order is irrelevant
V = list()
V[["alt1"]] = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
V[["alt2"]] = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
V[["alt3"]] = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
### Define settings for MNL model component
mnl_settings = list(
alternatives  = c(alt1=1, alt2=2, alt3=3),
avail         = list(TRAIN_AV=1, SM_AV=2, CAR_AV=3),
choiceVar     = CHOICE,
utilities     = V
)
### Compute probabilities using MNL model
P[["model"]] = apollo_mnl(mnl_settings, functionality)
### Take product across observation for same individual
P = apollo_panelProd(P, apollo_inputs, functionality)
### Average across inter-individual draws
P = apollo_avgInterDraws(P, apollo_inputs, functionality)
### Prepare and return outputs of function
P = apollo_prepareProb(P, apollo_inputs, functionality)
return(P)
}
?apollo_validateInputs()
apollo_inputs = apollo_validateInputs(database = db_swissmetro)
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
### Function initialisation: do not change the following three commands
### Attach inputs and detach after function exit
apollo_attach(apollo_beta, apollo_inputs)
on.exit(apollo_detach(apollo_beta, apollo_inputs))
### Create list of probabilities P
P = list()
### List of utilities: these must use the same names as in mnl_settings, order is irrelevant
V = list()
V[["alt1"]] = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
V[["alt2"]] = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
V[["alt3"]] = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
### Define settings for MNL model component
mnl_settings = list(
alternatives  = c(alt1=1, alt2=2, alt3=3),
avail         = list(TRAIN_AV=1, SM_AV=2, CAR_AV=3),
choiceVar     = CHOICE,
utilities     = V
)
### Compute probabilities using MNL model
P[["model"]] = apollo_mnl(mnl_settings, functionality)
### Take product across observation for same individual
P = apollo_panelProd(P, apollo_inputs, functionality)
### Average across inter-individual draws
P = apollo_avgInterDraws(P, apollo_inputs, functionality)
### Prepare and return outputs of function
P = apollo_prepareProb(P, apollo_inputs, functionality)
return(P)
}
model = apollo_estimate(apollo_beta, apollo_fixed,apollo_probabilities, apollo_inputs)
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
### Function initialisation: do not change the following three commands
### Attach inputs and detach after function exit
apollo_attach(apollo_beta, apollo_inputs)
on.exit(apollo_detach(apollo_beta, apollo_inputs))
### Create list of probabilities P
P = list()
### List of utilities: these must use the same names as in mnl_settings, order is irrelevant
V = list()
V[["alt1"]] = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
V[["alt2"]] = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
V[["alt3"]] = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
### Define settings for MNL model component
mnl_settings = list(
alternatives  = c(alt1=1, alt2=2, alt3=3),
avail         = list(alt1=TRAIN_AV, alt2=SM_AV, alt3=CAR_AV),
choiceVar     = CHOICE,
utilities     = V
)
### Compute probabilities using MNL model
P[["model"]] = apollo_mnl(mnl_settings, functionality)
### Take product across observation for same individual
P = apollo_panelProd(P, apollo_inputs, functionality)
### Average across inter-individual draws
P = apollo_avgInterDraws(P, apollo_inputs, functionality)
### Prepare and return outputs of function
P = apollo_prepareProb(P, apollo_inputs, functionality)
return(P)
}
model = apollo_estimate(apollo_beta, apollo_fixed,apollo_probabilities, apollo_inputs)
knitr::opts_chunk$set(echo = TRUE)
### Clear memory
rm(list = ls())
### Load Apollo library
library(apollo)
#load dplyr library
library(dplyr)
### Initialise code
apollo_initialise()
### Set core controls
apollo_control = list(
modelName       = "Swissmetro",
modelDescr      = "Mixed logit model on Swissmetro, uncorrelated Lognormals in preference space",
indivID         = "ID",
nCores          = 4,
outputDirectory = "output"
)
file_path <- "C:/Users/alexi/Desktop/GITS/Semester-project/Data/swissmetro.dat"
db_swissmetro = read.table(file_path, header = TRUE)
exclude <- with(db_swissmetro, ((db_swissmetro$PURPOSE != 1) * (db_swissmetro$PURPOSE != 3) + (db_swissmetro$CHOICE == 0)) > 0)
db_swissmetro <- subset(db_swissmetro, !exclude) #This makes us go from  10,728 observations (rows) to 6,768
#To not refere to database_swissmetro everytime
#We define the new variables that we will use later and add them directly to the database
db_swissmetro$SM_COST <- db_swissmetro$SM_CO * (db_swissmetro$GA == 0)
db_swissmetro$TRAIN_COST <- db_swissmetro$TRAIN_CO * (db_swissmetro$GA == 0)
db_swissmetro$CAR_AV_SP <- db_swissmetro$CAR_AV * (db_swissmetro$SP != 0)
db_swissmetro$TRAIN_AV_SP <- db_swissmetro$TRAIN_AV * (db_swissmetro$SP != 0)
db_swissmetro$TRAIN_TT_SCALED <- db_swissmetro$TRAIN_TT / 100
db_swissmetro$TRAIN_COST_SCALED <- db_swissmetro$TRAIN_COST / 100
db_swissmetro$SM_TT_SCALED <- db_swissmetro$SM_TT / 100
db_swissmetro$CAR_TT_SCALED<- db_swissmetro$CAR_TT / 100
db_swissmetro$CAR_CO_SCALED <- db_swissmetro$CAR_CO / 100
db_swissmetro$SM_COST_SCALED <- db_swissmetro$SM_COST / 100 #idk why it doesnt rescale the SM_COST when exluding some of the data
#This makes us go from  28 variables (columns) to 38
### Vector of parameters, including any that are kept fixed in estimation
apollo_beta = c(ASC_CAR        = 0,
ASC_TRAIN      = 0,
ASC_SM         = 0,
B_COST         = 0,
B_TIME         = 0,
B_TIME_S       = 1)
### Vector with names (in quotes) of parameters to be kept fixed at their starting value in apollo_beta, use apollo_beta_fixed = c() if none
apollo_fixed = c("ASC_SM")
### Set parameters for generating draws
apollo_draws = list(
interDrawsType = "halton", #differences btw individuals
interNDraws    = 100,
interUnifDraws = c(),
interNormDraws = c("draws"),  #Standard Normal dist draws
intraDrawsType = "halton",
intraNDraws    = 0,
intraUnifDraws = c(),
intraNormDraws = c()
)
### Create random parameters
apollo_randCoeff = function(apollo_beta, apollo_inputs){
randcoeff = list()
randcoeff[["B_TIME_RND"]] = B_TIME + B_TIME_S * draws
return(randcoeff)
}
apollo_inputs = apollo_validateInputs(database = db_swissmetro) #have to specify the name of the database, as it is by default called "database"
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
### Function initialisation: do not change the following three commands
### Attach inputs and detach after function exit
apollo_attach(apollo_beta, apollo_inputs)
on.exit(apollo_detach(apollo_beta, apollo_inputs))
### Create list of probabilities P
P = list()
### List of utilities: these must use the same names as in mnl_settings, order is irrelevant
V = list()
V[["alt1"]] = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
V[["alt2"]] = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
V[["alt3"]] = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
### Define settings for MNL model component
mnl_settings = list(
alternatives  = c(alt1=1, alt2=2, alt3=3),
avail         = list(alt1=TRAIN_AV, alt2=SM_AV, alt3=CAR_AV),
choiceVar     = CHOICE,
utilities     = V
)
### Compute probabilities using MNL model
P[["model"]] = apollo_mnl(mnl_settings, functionality)
### Take product across observation for same individual
P = apollo_panelProd(P, apollo_inputs, functionality)
### Average across inter-individual draws
P = apollo_avgInterDraws(P, apollo_inputs, functionality)
### Prepare and return outputs of function
P = apollo_prepareProb(P, apollo_inputs, functionality)
return(P)
}
model = apollo_estimate(apollo_beta, apollo_fixed,apollo_probabilities, apollo_inputs)
unconditionals = apollo_unconditionals(model, apollo_probabilities, apollo_inputs)
apollo_modelOutput(model) #(FORMATTED OUTPUT (TO SCREEN))
apollo_saveOutput(model) #(FORMATTED OUTPUT (TO FILE, using model name))
unconditionals
dim(unconditionals)
View(unconditionals)
unconditionals <- apollo_unconditionals(model, apollo_probabilities, apollo_inputs) #actual values used for random coefficients, want to import them as a excel table
View(unconditionals)
dim(unconditionals)
unconditionals
#library to export coefficient in excel table
library(openxlsx)
unconditionals[["B_TIME_RND"]]
install.packages("openxlsx")
#library to export coefficient in excel table
library(openxlsx)
write.csv(unconditionals, "test.csv")
write.csv(unconditionals, "random_coefficients_Apollo .csv")
write.csv(unconditionals, "random_coefficients_Apollo.csv")
