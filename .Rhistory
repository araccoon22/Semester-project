mu_log_b_tc    = -3,
sigma_log_b_tc = -0.01,
mu_log_b_hw    = -3,
sigma_log_b_hw = -0.01,
mu_log_b_ch    = -3,
sigma_log_b_ch = -0.01)
### Vector with names (in quotes) of parameters to be kept fixed at their starting value in apollo_beta, use apollo_beta_fixed = c() if none
apollo_fixed = c()
### Set parameters for generating draws
apollo_draws = list(
interDrawsType = "halton",
interNDraws    = 500,
interUnifDraws = c(),
interNormDraws = c("draws_tt","draws_tc","draws_hw","draws_ch"),  #Standard Normal dist draws
intraDrawsType = "halton",
intraNDraws    = 0,
intraUnifDraws = c(),
intraNormDraws = c()
)
### Create random parameters
apollo_randCoeff = function(apollo_beta, apollo_inputs){
randcoeff = list()
randcoeff[["b_tt"]] = -exp( mu_log_b_tt + sigma_log_b_tt * draws_tt )
randcoeff[["b_tc"]] = -exp( mu_log_b_tc + sigma_log_b_tc * draws_tc )
randcoeff[["b_hw"]] = -exp( mu_log_b_hw + sigma_log_b_hw * draws_hw )
randcoeff[["b_ch"]] = -exp( mu_log_b_ch + sigma_log_b_ch * draws_ch )
return(randcoeff)
}
apollo_inputs = apollo_validateInputs()
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
### Function initialisation: do not change the following three commands
### Attach inputs and detach after function exit
apollo_attach(apollo_beta, apollo_inputs)
on.exit(apollo_detach(apollo_beta, apollo_inputs))
### Create list of probabilities P
P = list()
### List of utilities: these must use the same names as in mnl_settings, order is irrelevant
V = list()
V[["alt1"]] = b_tt * tt1 + b_tc * tc1 + b_hw * hw1 + b_ch * ch1
V[["alt2"]] = b_tt * tt2 + b_tc * tc2 + b_hw * hw2 + b_ch * ch2
### Define settings for MNL model component
mnl_settings = list(
alternatives  = c(alt1=1, alt2=2),
avail         = list(alt1=1, alt2=1),
choiceVar     = choice,
utilities     = V
)
### Compute probabilities using MNL model
P[["model"]] = apollo_mnl(mnl_settings, functionality)
### Take product across observation for same individual
P = apollo_panelProd(P, apollo_inputs, functionality)
### Average across inter-individual draws
P = apollo_avgInterDraws(P, apollo_inputs, functionality)
### Prepare and return outputs of function
P = apollo_prepareProb(P, apollo_inputs, functionality)
return(P)
}
model = apollo_estimate(apollo_beta, apollo_fixed,apollo_probabilities, apollo_inputs)
knitr::opts_chunk$set(echo = TRUE)
### Clear memory
rm(list = ls())
### Load Apollo library
library(apollo)
#load dplyr library
library(dplyr)
### Initialise code
apollo_initialise()
### Set core controls
apollo_control = list(
modelName       = "MMNL_preference_space",
modelDescr      = "Mixed logit model on Swiss route choice data, uncorrelated Lognormals in preference space",
indivID         = "ID",
nCores          = 4,
outputDirectory = "output"
)
monitor_system <- function(duration_minute) {
duration <- duration_minute * 60  # transforming the argument so it's in minutes instead of seconds
data <- data.frame(`Time` = numeric(), `CPU Usage (%)` = numeric(), `RAM Usage (%)` = numeric())
start_time <- Sys.time()
while (difftime(Sys.time(), start_time, units = "secs") < duration) {
elapsed_time <- difftime(Sys.time(), start_time, units = "secs")
cpu_percent <- system("wmic cpu get loadpercentage | findstr [0-9]", intern = TRUE)
ram_info <- system("wmic OS get FreePhysicalMemory /Value", intern = TRUE)
ram_percent <- 100 - as.numeric(sub("\\D", "", ram_info)) / as.numeric(system("wmic computersystem get TotalPhysicalMemory /Value", intern = TRUE)) * 100
data <- rbind(data, data.frame(`Time` = elapsed_time, `CPU Usage (%)` = as.numeric(cpu_percent), `RAM Usage (%)` = ram_percent))
Sys.sleep(60)  # measure the CPU + RAM every minute
}
return(data)
}
# Example usage:
# df_monitor <- monitor_system(5) # Monitor for 5 minutes
### Loading data from package
### if data is to be loaded from a file (e.g. called data.csv),
### the code would be: database = read.csv("data.csv",header=TRUE)
database = apollo_swissRouteChoiceData
### for data dictionary, use ?apollo_swissRouteChoiceData
### Note this is unlabelled data, so we are doing this for an illustration of cheap vs expensive
### Define settings for analysis of choice data to be conducted prior to model estimation
choiceAnalysis_settings <- list(
alternatives = c(cheap=1, expensive=2),
choiceVar    = (1*((database$choice==1)*(database$tc1<=database$tc2)+(database$choice==2)*(database$tc1>=database$tc2))
+2*((database$choice==1)*(database$tc1>=database$tc2)+(database$choice==2)*(database$tc1<=database$tc2))),
explanators  = database[,c("car_availability","hh_inc_abs","business")]
)
### Run function to analyse choice data
apollo_choiceAnalysis(choiceAnalysis_settings, apollo_control, database)
### Vector of parameters, including any that are kept fixed in estimation
apollo_beta = c(mu_log_b_tt    = -3,
sigma_log_b_tt = -0.01,
mu_log_b_tc    = -3,
sigma_log_b_tc = -0.01,
mu_log_b_hw    = -3,
sigma_log_b_hw = -0.01,
mu_log_b_ch    = -3,
sigma_log_b_ch = -0.01)
### Vector with names (in quotes) of parameters to be kept fixed at their starting value in apollo_beta, use apollo_beta_fixed = c() if none
apollo_fixed = c()
### Set parameters for generating draws
apollo_draws = list(
interDrawsType = "halton",
interNDraws    = 500,
interUnifDraws = c(),
interNormDraws = c("draws_tt","draws_tc","draws_hw","draws_ch"),  #Standard Normal dist draws
intraDrawsType = "halton",
intraNDraws    = 0,
intraUnifDraws = c(),
intraNormDraws = c()
)
### Create random parameters
apollo_randCoeff = function(apollo_beta, apollo_inputs){
randcoeff = list()
randcoeff[["b_tt"]] = -exp( mu_log_b_tt + sigma_log_b_tt * draws_tt )
randcoeff[["b_tc"]] = -exp( mu_log_b_tc + sigma_log_b_tc * draws_tc )
randcoeff[["b_hw"]] = -exp( mu_log_b_hw + sigma_log_b_hw * draws_hw )
randcoeff[["b_ch"]] = -exp( mu_log_b_ch + sigma_log_b_ch * draws_ch )
return(randcoeff)
}
apollo_inputs = apollo_validateInputs()
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
### Function initialisation: do not change the following three commands
### Attach inputs and detach after function exit
apollo_attach(apollo_beta, apollo_inputs)
on.exit(apollo_detach(apollo_beta, apollo_inputs))
### Create list of probabilities P
P = list()
### List of utilities: these must use the same names as in mnl_settings, order is irrelevant
V = list()
V[["alt1"]] = b_tt * tt1 + b_tc * tc1 + b_hw * hw1 + b_ch * ch1
V[["alt2"]] = b_tt * tt2 + b_tc * tc2 + b_hw * hw2 + b_ch * ch2
### Define settings for MNL model component
mnl_settings = list(
alternatives  = c(alt1=1, alt2=2),
avail         = list(alt1=1, alt2=1),
choiceVar     = choice,
utilities     = V
)
### Compute probabilities using MNL model
P[["model"]] = apollo_mnl(mnl_settings, functionality)
### Take product across observation for same individual
P = apollo_panelProd(P, apollo_inputs, functionality)
### Average across inter-individual draws
P = apollo_avgInterDraws(P, apollo_inputs, functionality)
### Prepare and return outputs of function
P = apollo_prepareProb(P, apollo_inputs, functionality)
return(P)
}
model = apollo_estimate(apollo_beta, apollo_fixed,apollo_probabilities, apollo_inputs)
apollo_modelOutput(model) #(FORMATTED OUTPUT (TO SCREEN))
apollo_saveOutput(model) #(FORMATTED OUTPUT (TO FILE, using model name))
knitr::opts_chunk$set(echo = TRUE)
### Clear memory
rm(list = ls())
### Load Apollo library
library(apollo)
#load dplyr library
library(dplyr)
### Initialise code
apollo_initialise()
### Set core controls
apollo_control = list(
modelName       = "MMNL_preference_space",
modelDescr      = "Mixed logit model on Swiss route choice data, uncorrelated Lognormals in preference space",
indivID         = "ID",
nCores          = 4,
outputDirectory = "output"
)
monitor_system <- function(duration_minute) {
duration <- duration_minute * 60  # transforming the argument so it's in minutes instead of seconds
data <- data.frame(`Time` = numeric(), `CPU Usage (%)` = numeric(), `RAM Usage (%)` = numeric())
start_time <- Sys.time()
while (difftime(Sys.time(), start_time, units = "secs") < duration) {
elapsed_time <- difftime(Sys.time(), start_time, units = "secs")
cpu_percent <- system("wmic cpu get loadpercentage | findstr [0-9]", intern = TRUE)
ram_info <- system("wmic OS get FreePhysicalMemory /Value", intern = TRUE)
ram_percent <- 100 - as.numeric(sub("\\D", "", ram_info)) / as.numeric(system("wmic computersystem get TotalPhysicalMemory /Value", intern = TRUE)) * 100
data <- rbind(data, data.frame(`Time` = elapsed_time, `CPU Usage (%)` = as.numeric(cpu_percent), `RAM Usage (%)` = ram_percent))
Sys.sleep(60)  # measure the CPU + RAM every minute
}
return(data)
}
# Example usage:
# df_monitor <- monitor_system(5) # Monitor for 5 minutes
### Loading data from package
### if data is to be loaded from a file (e.g. called data.csv),
### the code would be: database = read.csv("data.csv",header=TRUE)
database = apollo_swissRouteChoiceData
### for data dictionary, use ?apollo_swissRouteChoiceData
### Note this is unlabelled data, so we are doing this for an illustration of cheap vs expensive
### Define settings for analysis of choice data to be conducted prior to model estimation
choiceAnalysis_settings <- list(
alternatives = c(cheap=1, expensive=2),
choiceVar    = (1*((database$choice==1)*(database$tc1<=database$tc2)+(database$choice==2)*(database$tc1>=database$tc2))
+2*((database$choice==1)*(database$tc1>=database$tc2)+(database$choice==2)*(database$tc1<=database$tc2))),
explanators  = database[,c("car_availability","hh_inc_abs","business")]
)
### Run function to analyse choice data
apollo_choiceAnalysis(choiceAnalysis_settings, apollo_control, database)
### Vector of parameters, including any that are kept fixed in estimation
apollo_beta = c(mu_log_b_tt    = -3,
sigma_log_b_tt = -0.01,
mu_log_b_tc    = -3,
sigma_log_b_tc = -0.01,
mu_log_b_hw    = -3,
sigma_log_b_hw = -0.01,
mu_log_b_ch    = -3,
sigma_log_b_ch = -0.01)
### Vector with names (in quotes) of parameters to be kept fixed at their starting value in apollo_beta, use apollo_beta_fixed = c() if none
apollo_fixed = c()
### Set parameters for generating draws
apollo_draws = list(
interDrawsType = "halton",
interNDraws    = 500,
interUnifDraws = c(),
interNormDraws = c("draws_tt","draws_tc","draws_hw","draws_ch"),  #Standard Normal dist draws
intraDrawsType = "halton",
intraNDraws    = 0,
intraUnifDraws = c(),
intraNormDraws = c()
)
### Create random parameters
apollo_randCoeff = function(apollo_beta, apollo_inputs){
randcoeff = list()
randcoeff[["b_tt"]] = -exp( mu_log_b_tt + sigma_log_b_tt * draws_tt )
randcoeff[["b_tc"]] = -exp( mu_log_b_tc + sigma_log_b_tc * draws_tc )
randcoeff[["b_hw"]] = -exp( mu_log_b_hw + sigma_log_b_hw * draws_hw )
randcoeff[["b_ch"]] = -exp( mu_log_b_ch + sigma_log_b_ch * draws_ch )
return(randcoeff)
}
apollo_inputs = apollo_validateInputs()
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
### Function initialisation: do not change the following three commands
### Attach inputs and detach after function exit
apollo_attach(apollo_beta, apollo_inputs)
on.exit(apollo_detach(apollo_beta, apollo_inputs))
### Create list of probabilities P
P = list()
### List of utilities: these must use the same names as in mnl_settings, order is irrelevant
V = list()
V[["alt1"]] = b_tt * tt1 + b_tc * tc1 + b_hw * hw1 + b_ch * ch1
V[["alt2"]] = b_tt * tt2 + b_tc * tc2 + b_hw * hw2 + b_ch * ch2
### Define settings for MNL model component
mnl_settings = list(
alternatives  = c(alt1=1, alt2=2),
avail         = list(alt1=1, alt2=1),
choiceVar     = choice,
utilities     = V
)
### Compute probabilities using MNL model
P[["model"]] = apollo_mnl(mnl_settings, functionality)
### Take product across observation for same individual
P = apollo_panelProd(P, apollo_inputs, functionality)
### Average across inter-individual draws
P = apollo_avgInterDraws(P, apollo_inputs, functionality)
### Prepare and return outputs of function
P = apollo_prepareProb(P, apollo_inputs, functionality)
return(P)
}
model = apollo_estimate(apollo_beta, apollo_fixed,apollo_probabilities, apollo_inputs)
apollo_modelOutput(model) #(FORMATTED OUTPUT (TO SCREEN))
apollo_saveOutput(model) #(FORMATTED OUTPUT (TO FILE, using model name))
knitr::opts_chunk$set(echo = TRUE)
### Clear memory
rm(list = ls())
### Load Apollo library
library(apollo)
#load dplyr library
library(dplyr)
### Initialise code
apollo_initialise()
### Set core controls
apollo_control = list(
modelName       = "MMNL_preference_space",
modelDescr      = "Mixed logit model on Swiss route choice data, uncorrelated Lognormals in preference space",
indivID         = "ID",
nCores          = 4,
outputDirectory = "output"
)
monitor_system <- function(duration_minute) {
duration <- duration_minute * 60  # transforming the argument so it's in minutes instead of seconds
data <- data.frame(`Time` = numeric(), `CPU Usage (%)` = numeric(), `RAM Usage (%)` = numeric())
start_time <- Sys.time()
while (difftime(Sys.time(), start_time, units = "secs") < duration) {
elapsed_time <- difftime(Sys.time(), start_time, units = "secs")
cpu_percent <- system("wmic cpu get loadpercentage | findstr [0-9]", intern = TRUE)
ram_info <- system("wmic OS get FreePhysicalMemory /Value", intern = TRUE)
ram_percent <- 100 - as.numeric(sub("\\D", "", ram_info)) / as.numeric(system("wmic computersystem get TotalPhysicalMemory /Value", intern = TRUE)) * 100
data <- rbind(data, data.frame(`Time` = elapsed_time, `CPU Usage (%)` = as.numeric(cpu_percent), `RAM Usage (%)` = ram_percent))
Sys.sleep(60)  # measure the CPU + RAM every minute
}
return(data)
}
# Example usage:
# df_monitor <- monitor_system(5) # Monitor for 5 minutes
### Loading data from package
### if data is to be loaded from a file (e.g. called data.csv),
### the code would be: database = read.csv("data.csv",header=TRUE)
database = apollo_swissRouteChoiceData
### for data dictionary, use ?apollo_swissRouteChoiceData
### Note this is unlabelled data, so we are doing this for an illustration of cheap vs expensive
### Define settings for analysis of choice data to be conducted prior to model estimation
choiceAnalysis_settings <- list(
alternatives = c(cheap=1, expensive=2),
choiceVar    = (1*((database$choice==1)*(database$tc1<=database$tc2)+(database$choice==2)*(database$tc1>=database$tc2))
+2*((database$choice==1)*(database$tc1>=database$tc2)+(database$choice==2)*(database$tc1<=database$tc2))),
explanators  = database[,c("car_availability","hh_inc_abs","business")]
)
### Run function to analyse choice data
apollo_choiceAnalysis(choiceAnalysis_settings, apollo_control, database)
### Vector of parameters, including any that are kept fixed in estimation
apollo_beta = c(mu_log_b_tt    = -3,
sigma_log_b_tt = -0.01,
mu_log_b_tc    = -3,
sigma_log_b_tc = -0.01,
mu_log_b_hw    = -3,
sigma_log_b_hw = -0.01,
mu_log_b_ch    = -3,
sigma_log_b_ch = -0.01)
### Vector with names (in quotes) of parameters to be kept fixed at their starting value in apollo_beta, use apollo_beta_fixed = c() if none
apollo_fixed = c()
### Set parameters for generating draws
apollo_draws = list(
interDrawsType = "halton",
interNDraws    = 500,
interUnifDraws = c(),
interNormDraws = c("draws_tt","draws_tc","draws_hw","draws_ch"),  #Standard Normal dist draws
intraDrawsType = "halton",
intraNDraws    = 0,
intraUnifDraws = c(),
intraNormDraws = c()
)
### Create random parameters
apollo_randCoeff = function(apollo_beta, apollo_inputs){
randcoeff = list()
randcoeff[["b_tt"]] = -exp( mu_log_b_tt + sigma_log_b_tt * draws_tt )
randcoeff[["b_tc"]] = -exp( mu_log_b_tc + sigma_log_b_tc * draws_tc )
randcoeff[["b_hw"]] = -exp( mu_log_b_hw + sigma_log_b_hw * draws_hw )
randcoeff[["b_ch"]] = -exp( mu_log_b_ch + sigma_log_b_ch * draws_ch )
return(randcoeff)
}
apollo_inputs = apollo_validateInputs()
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
### Function initialisation: do not change the following three commands
### Attach inputs and detach after function exit
apollo_attach(apollo_beta, apollo_inputs)
on.exit(apollo_detach(apollo_beta, apollo_inputs))
### Create list of probabilities P
P = list()
### List of utilities: these must use the same names as in mnl_settings, order is irrelevant
V = list()
V[["alt1"]] = b_tt * tt1 + b_tc * tc1 + b_hw * hw1 + b_ch * ch1
V[["alt2"]] = b_tt * tt2 + b_tc * tc2 + b_hw * hw2 + b_ch * ch2
### Define settings for MNL model component
mnl_settings = list(
alternatives  = c(alt1=1, alt2=2),
avail         = list(alt1=1, alt2=1),
choiceVar     = choice,
utilities     = V
)
### Compute probabilities using MNL model
P[["model"]] = apollo_mnl(mnl_settings, functionality)
### Take product across observation for same individual
P = apollo_panelProd(P, apollo_inputs, functionality)
### Average across inter-individual draws
P = apollo_avgInterDraws(P, apollo_inputs, functionality)
### Prepare and return outputs of function
P = apollo_prepareProb(P, apollo_inputs, functionality)
return(P)
}
model = apollo_estimate(apollo_beta, apollo_fixed,apollo_probabilities, apollo_inputs)
apollo_modelOutput(model) #(FORMATTED OUTPUT (TO SCREEN))
apollo_saveOutput(model) #(FORMATTED OUTPUT (TO FILE, using model name))
knitr::opts_chunk$set(echo = TRUE)
### Clear memory
rm(list = ls())
###Set time
start_time <- Sys.time()
### Load Apollo library
library(apollo)
### Initialise code
apollo_initialise()
### Set core controls
apollo_control = list(
modelName       = "MNL_RP",
modelDescr      = "Simple MNL model on mode choice RP data",
indivID         = "ID", #indicate which columns of the data is the decision maker
outputDirectory = "output"
)
### if data is to be loaded from a file (e.g. called data.csv),
### the code would be: database = read.csv("data.csv",header=TRUE)
database = apollo_modeChoiceData #simulated dataset, 8'000 rows, 26 variables (25 + id)
database #long format
colnames(database) #see column names
### for data dictionary, use ?apollo_modeChoiceData
### Use only RP data
database = subset(database,database$RP==1)
### Vector of parameters, including any that are kept fixed in estimation
apollo_beta=c(asc_car   = 0,
asc_bus   = 0,
asc_air   = 0,
asc_rail  = 0,
b_tt_car  = 0,
b_tt_bus  = 0,
b_tt_air  = 0,
b_tt_rail = 0,
b_access  = 0,
b_cost    = 0)
### Vector with names (in quotes) of parameters to be kept fixed at their starting value in apollo_beta, use apollo_beta_fixed = c() if none
apollo_fixed = c("asc_car") #ASC that will not be estimated, should keep it empty (apollo_fixed = c() if all param need to be estimated)
apollo_inputs = apollo_validateInputs() #Searches the user work space (.GlobalEnv) for all necessary input to run apollo_estimate, and packs it in a single list.
#specific to the model we estimate, user needs to define apollo_probabilities by themself
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
### Attach inputs and detach after function exit
apollo_attach(apollo_beta, apollo_inputs)
on.exit(apollo_detach(apollo_beta, apollo_inputs))
### Create list of probabilities P
P = list()
### List of utilities: these must use the same names as in mnl_settings, order is irrelevant
V = list()
V[["car"]]  = asc_car  + b_tt_car  * time_car                           + b_cost * cost_car
V[["bus"]]  = asc_bus  + b_tt_bus  * time_bus  + b_access * access_bus  + b_cost * cost_bus
V[["air"]]  = asc_air  + b_tt_air  * time_air  + b_access * access_air  + b_cost * cost_air
V[["rail"]] = asc_rail + b_tt_rail * time_rail + b_access * access_rail + b_cost * cost_rail
### Define settings for MNL model component
mnl_settings = list(
alternatives  = c(car=1, bus=2, air=3, rail=4),
avail         = list(car=av_car, bus=av_bus, air=av_air, rail=av_rail),
choiceVar     = choice,
utilities     = V
)
### Compute probabilities using MNL model
P[["model"]] = apollo_mnl(mnl_settings, functionality)
### Take product across observation for same individual
P = apollo_panelProd(P, apollo_inputs, functionality)
### Prepare and return outputs of function
P = apollo_prepareProb(P, apollo_inputs, functionality)
return(P)
}
model = apollo_estimate(apollo_beta, apollo_fixed, apollo_probabilities, apollo_inputs)
apollo_modelOutput(model)
apollo_saveOutput(model)
end_time <- Sys.time()
end_time - start_time
knitr::opts_chunk$set(echo = TRUE)
# Load required libraries
library(ggplot2)
# Read the CSV file
data_apollo <- read.csv("C:\\Users\\alexi\\Desktop\\GITS\\Semester-project\\Code\\cpu_ram_usage_apollo.csv")
colnames(data_apollo) <- c("Time", "CPU", "RAM")
# Read the CSV file
data_biogeme <- read.csv("C:\\Users\\alexi\\Desktop\\GITS\\Semester-project\\Code\\cpu_ram_usage_biogeme.csv")
colnames(data_biogeme) <- c("Time", "CPU", "RAM")
# Plot using ggplot2
ggplot(data_apollo, aes(x = Time, group = 1)) +
geom_line(aes(y = CPU, color = "CPU")) +
geom_line(aes(y = RAM, color = "RAM")) +
labs(x = "Time Passed (seconds)", y = "Usage (%)", color = "Metric") +
scale_color_manual(values = c("CPU" = "red", "RAM" = "blue")) +
ggtitle("CPU and RAM Usage Over Time") +
theme_minimal()
# Plot using ggplot2
ggplot(data_biogeme, aes(x = Time, group = 1)) +
geom_line(aes(y = CPU, color = "CPU")) +
geom_line(aes(y = RAM, color = "RAM")) +
labs(x = "Time Passed (seconds)", y = "Usage (%)", color = "Metric") +
scale_color_manual(values = c("CPU" = "red", "RAM" = "blue")) +
ggtitle("CPU and RAM Usage Over Time") +
theme_minimal()
knitr::opts_chunk$set(echo = TRUE)
# Load required libraries
library(ggplot2)
# Read the CSV file
data_apollo <- read.csv("C:\\Users\\alexi\\Desktop\\GITS\\Semester-project\\Code\\cpu_ram_usage_apollo.csv")
colnames(data_apollo) <- c("Time", "CPU", "RAM")
# Read the CSV file
data_biogeme <- read.csv("C:\\Users\\alexi\\Desktop\\GITS\\Semester-project\\Code\\cpu_ram_usage_biogeme.csv")
colnames(data_biogeme) <- c("Time", "CPU", "RAM")
# Plot using ggplot2
ggplot(data_apollo, aes(x = Time, group = 1)) +
geom_line(aes(y = CPU, color = "CPU")) +
geom_line(aes(y = RAM, color = "RAM")) +
labs(x = "Time Passed (seconds)", y = "Usage (%)", color = "Metric") +
scale_color_manual(values = c("CPU" = "red", "RAM" = "blue")) +
ggtitle("CPU and RAM Usage Over Time (Apollo)") +
theme_minimal()
# Plot using ggplot2
ggplot(data_biogeme, aes(x = Time, group = 1)) +
geom_line(aes(y = CPU, color = "CPU")) +
geom_line(aes(y = RAM, color = "RAM")) +
labs(x = "Time Passed (seconds)", y = "Usage (%)", color = "Metric") +
scale_color_manual(values = c("CPU" = "red", "RAM" = "blue")) +
ggtitle("CPU and RAM Usage Over Time (Biogeme)") +
theme_minimal()
